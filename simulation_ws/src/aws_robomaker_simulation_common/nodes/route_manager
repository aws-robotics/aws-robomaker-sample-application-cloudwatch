#!/usr/bin/env python
"""
 Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License").
 You may not use this file except in compliance with the License.
 A copy of the License is located at

  http://aws.amazon.com/apache2.0

 or in the "license" file accompanying this file. This file is distributed
 on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 express or implied. See the License for the specific language governing
 permissions and limitations under the License.
"""
import random
import itertools
import rospy
import actionlib
import tf.transformations as tf
from geometry_msgs.msg import Point, Quaternion
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal

from nav_msgs.msg import MapMetaData, OccupancyGrid
from geometry_msgs.msg import Pose
from math import cos, sin
import numpy as np

class GoalGenerator():

    def __init__(self):
        # rospy.init_node('listener', anonymous=True)
        self.meta_data = rospy.wait_for_message("map_metadata", MapMetaData)
        self.occupancy_data = rospy.wait_for_message("map", OccupancyGrid)


    def unravel_index(self, x, y):
        return x*(self.meta_data.width) + y


    def grid_to_world(self, x, y):
        theta = self.meta_data.origin.position.z #(in rad) 
        res = self.meta_data.resolution
        x0 = self.meta_data.origin.position.x
        y0 = self.meta_data.origin.position.y
        x_world = x0 + (cos(-theta)*(res*x) - sin(-theta)*(res*y))
        y_world = y0 + (sin(-theta)*(res*x) + cos(-theta)*(res*y))

        return [x_world, y_world]


    def _create_pos(self, x_world, y_world, z_world, euler_orientation_x, euler_orientation_y, euler_orientation_z):
        p = Pose()
        p.position.x = x_world
        p.position.y = y_world
        p.position.z = z_world

        # Make sure the quaternion is valid and normalized
        quaternion_orientation = tf.quaternion_from_euler(euler_orientation_x, euler_orientation_y, euler_orientation_z)
        p.orientation.x = quaternion_orientation[0]
        p.orientation.y = quaternion_orientation[1]
        p.orientation.z = quaternion_orientation[2]
        p.orientation.w = quaternion_orientation[3]

        return p


    def check_noise(self, x, y, row_id=None):
        #in grid coordinates
        #returns false if noise, else true
        delta_x=max(2,self.meta_data.width//50) #to make it depend on resolution
        delta_y=max(2,self.meta_data.height//50)

        l_bound, r_bound = max(0, x-delta_x), min(self.meta_data.width-1, x+delta_x)
        t_bound, b_bound = max(0, y-delta_y), min(self.meta_data.height-1, y+delta_y)

        for _x in range(l_bound, r_bound):
            for _y in range(t_bound, b_bound):
                _row_id = self.unravel_index(_y, _x)
                if self.occupancy_data.data[_row_id]!=0:
                    return False

        return True


    def get_valid_random_world_pos(self):
        z_world_floor = 0.
        euler_orientation = [0.,0.,0.]

        rospy.loginfo("Searching for a valid goal")
        timeout_iter = 100
        iteration = 0
        while iteration<timeout_iter:
          _x, _y = random.randint(0,self.meta_data.width-1), random.randint(0,self.meta_data.height-1)
          _row_id = self.unravel_index(_y, _x)
          if self.occupancy_data.data[_row_id]==0 and self.check_noise(_x, _y, row_id=_row_id): 
            x_world, y_world  = self.grid_to_world(_x, _y)
            rospy.loginfo("Valid goal found!")
            return self._create_pos(x_world, y_world, z_world_floor, *euler_orientation)

        # TODO: add more to error description if possible? (what could be the causes for this?)
        rospy.logerr("Could not find a valid goal in the world.")
        return None


class RouteManager():
    '''Send goals to move_base server for the specified route. Routes forever.

       Loads the route from yaml. 
       Use RViz to record 2D nav goals. 
       Echo the input goal on topic /move_base_simpl/goal

       Format: 

            order: inorder
            poses: 
                - pose: 
                      position: 
                        x: -5.41667556763
                        y: -3.14395284653
                        z: 0.0
                      orientation: 
                        x: 0.0
                        y: 0.0
                        z: 0.785181432231
                        w: 0.619265789851
    
    '''

    def __init__(self):
        self.route = []

        self.client = actionlib.SimpleActionClient('move_base', MoveBaseAction)
        self.client.wait_for_server()

        self.map = GoalGenerator()
        rospy.loginfo("Route manager initialized with random goal generator")


    def to_move_goal(self, pose):
        if pose is None:
            raise ValueError("Goal position cannot be NULL")

        goal = MoveBaseGoal()
        goal.target_pose.header.stamp = rospy.Time.now()
        goal.target_pose.header.frame_id = "map"
        goal.target_pose.pose.position = pose.position
        goal.target_pose.pose.orientation = pose.orientation
        return goal


    def route_forever(self):
        rate = rospy.Rate(1)
        while not rospy.is_shutdown():
            try:
                rospy.loginfo("Quering goal generator for the next goal")
                current_goal = self.to_move_goal(self.map.get_valid_random_world_pos())
                rospy.loginfo("Sending target goal: %s", current_goal)
                self.client.send_goal(current_goal)

                if not self.client.wait_for_result():
                    rospy.logerr("Move server not ready, will try again...")
                else:
                    if self.client.get_result():
                        rospy.loginfo("Goal done: %s", current_goal)
                rate.sleep()
            except ValueError:
                rospy.loginfo("No valid goal found in the map, stopping route manager")
                return


def main():
    rospy.init_node('route_manager')
    try:
        route_manger = RouteManager()
        route_manger.route_forever()
    except rospy.ROSInterruptException:
        pass

if __name__ == '__main__':
    main()
